/** * @author - iSea_baidu @ 2016-01-24 03:50 * @brief - From sky to the sea. **/#include <cmath>#include <ctime>#include <cstdio>#include <cstring>#include <iostream>#include <algorithm>#include <fstream>#include <sstream>#include <vector>#include <string>#include <bitset>#include <queue>#include <unordered_map>#include <set>using namespace std;// SELF TEMPLATE CODE BGEIN#define LOG(level, fmt, arg...) \    fprintf(stderr, "[" #level "] [Line:%d] " fmt"\n", __LINE__, ##arg);#define NOTICE(fmt, arg...) LOG(NOTICE, fmt, ##arg)#define FATAL(fmt, arg...) LOG(FATAL, fmt, ##arg)#define DEBUG(x) do { \    stringstream ss; \    ss << #x << ": " << x; \    NOTICE("%s", ss.str().c_str()) \} while(0)#define SZ(x) ((int)((x).size()))#define rep(i,n) for (int i = 0; i < (n); ++i)#define repf(i,a,b) for (int i = (a); i <= (b); ++i)#define repcase int t, Case = 1; for (scanf("%d", &t); t; --t)template<class T> inline void to_min(T &a, const T b) { if (b < a) a = b; }template<class T> inline void to_max(T &a, const T b) { if (b > a) a = b; }// SELF TEMPLATE CODE ENDconst int inf = (-1u) >> 1;const int maxn = 1000 + 10;const int maxk = 33;const int mint = 1000010;struct Graph {    int w[maxk][maxk], lx[maxk], ly[maxk], matx[maxk], maty[maxk], n;    bool fx[maxk], fy[maxk];    void clear() {        memset(w, 0, sizeof(w));        n = 0;    }    void insert(int u, int v, int c) {        // NOTICE("insert %d -> %d %d", u, v, c);        to_max(n, max(u, v) + 1);        w[u][v] = c;    }    int maxmatch() {        memset(ly, 0, sizeof(ly));        for (int i = 0; i < n; ++i) {            lx[i] = -inf;            for (int j = 0; j < n; ++j) {                to_max(lx[i], w[i][j]);            }        }        memset(matx, -1, sizeof(matx));        memset(maty, -1, sizeof(maty));        for (int i = 0; i < n; ++i) {            memset(fx, false, sizeof(fx));            memset(fy, false, sizeof(fy));            if (!dfs(i)) {                --i;                int p = inf;                for (int k = 0; k < n; ++k) {                    if (fx[k] == true) {                        for (int j = 0; j < n; ++j) {                            if (fy[j] == false) {                                to_min(p, lx[k] + ly[j] - w[k][j]);                            }                        }                    }                }                for (int j = 0; j < n; ++j) {                    ly[j] += fy[j] * p;                }                for (int k = 0; k < n; ++k) {                    lx[k] -= fx[k] * p;                }            }        }        int ans = 0;        for (int i = 0; i < n; ++i) {            // if (maty[i] == -1) continue;            ans += w[maty[i]][i];            // NOTICE("match %d %d -> %d", maty[i], i, w[maty[i]][i]);        }        return ans;    }    bool dfs(int u) {        fx[u] = 1;        for (int v = 0; v < n; ++v) {            if (lx[u] + ly[v] == w[u][v] && fy[v] == false) {                fy[v] = true;                if (maty[v] == -1 || dfs(maty[v])) {                    matx[u] = v;                    maty[v] = u;                    return true;                }            }        }        return false;     }};Graph kmgraph;int n, k, p, c[maxn][maxk];vector<int> g[maxn];int dp[maxn][maxk][maxk];int ret;void update(int& x, int y) {    if (x == -1 || x > y) {        x = y;    }}void dfs(int x, int f) {    unordered_map<int, int> chnode_id;    int idx = 0;    for (const auto& nxt : g[x]) {        if (nxt != f) {            dfs(nxt, x);            chnode_id[nxt] = idx++;        }    }    // can same    rep (mycol, k) {        int samec = 0;        for (const auto& nxt : g[x]) {            if (nxt != f) {                int minc = (-1u) >> 1;                rep (chcol, k) {                    to_min(minc, dp[nxt][chcol][mycol]);                }                samec += minc;            }        }        if (x == 0) {            // update ans            to_min(ret, samec + c[x][mycol] + p);            // NOTICE("same ret %d", samec + c[x][mycol] + p);        } else {            rep (pacol, k) {                update(dp[x][mycol][pacol], samec + c[x][mycol] + p);            }        }    }    // cannot same    if (SZ(g[x]) > k) {        return;    }    rep (mycol, k) {        if (x == 0) {            kmgraph.clear();            for (const auto& nxt : g[x]) {                if (nxt != f) {                    rep (chcol, k) {                        kmgraph.insert(chnode_id[nxt], chcol, - dp[nxt][chcol][mycol]);                    }                }            }            int cost = kmgraph.maxmatch();            to_min(ret, - cost + c[x][mycol]);            // NOTICE("nonsame ret %d", - cost + c[x][mycol]);        } else {            rep (pacol, k) {                kmgraph.clear();                for (const auto& nxt : g[x]) {                    if (nxt != f) {                        rep (chcol, k) {                            if (chcol != pacol) {                                kmgraph.insert(chnode_id[nxt], chcol, - dp[nxt][chcol][mycol]);                            } else {                                kmgraph.insert(chnode_id[nxt], chcol, - inf);                            }                        }                    }                }                int cost = kmgraph.maxmatch();                update(dp[x][mycol][pacol], - cost + c[x][mycol]);            }        }    }}int main() {    repcase {        NOTICE("solving case %d...", Case);        scanf("%d%d%d", &n, &k, &p);        rep (i, n) rep (j, k) {            scanf("%d", &c[i][j]);        }        rep (i, n) {            g[i].clear();        }        rep (i, n - 1) {            int foo, bar;            scanf("%d%d", &foo, &bar);            --foo, --bar;            g[foo].push_back(bar);            g[bar].push_back(foo);        }        memset(dp, -1, sizeof(dp));        ret = inf;        dfs(0, -1);        printf("Case #%d: %d\n", Case++, ret);    }    return 0;}